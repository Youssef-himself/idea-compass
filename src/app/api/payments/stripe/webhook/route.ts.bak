export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';

export async function POST(request: NextRequest) {
  return NextResponse.json(
    { error: 'Stripe payments are currently disabled' },
    { status: 503 }
  );
        await handleSubscriptionUpdated(subscription);
        break;
      }
      
      case 'customer.subscription.deleted': {
        const subscription = event.data.object as Stripe.Subscription;
        await handleSubscriptionDeleted(subscription);
        break;
      }
      
      case 'invoice.payment_succeeded': {
        const invoice = event.data.object as Stripe.Invoice;
        await handleInvoicePaymentSucceeded(invoice);
        break;
      }
      
      case 'invoice.payment_failed': {
        const invoice = event.data.object as Stripe.Invoice;
        await handleInvoicePaymentFailed(invoice);
        break;
      }
      
      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Error processing webhook:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

async function handleCheckoutSessionCompleted(session: Stripe.Checkout.Session) {
  const userId = session.metadata?.userId;
  const plan = session.metadata?.plan;

  if (!userId || !plan) {
    console.error('Missing metadata in checkout session:', session.id);
    return;
  }

  // Update user's plan in Supabase
  const supabase = createServiceRoleClient();
  
  const { error } = await supabase
    .from('profiles')
    .update({
      plan: plan as 'pro' | 'premium',
      research_credits: plan === 'premium' ? 999999 : 50, // Unlimited for premium, 50 for pro
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to update user plan after payment:', error);
    throw error;
  }

  console.log(`Successfully upgraded user ${userId} to ${plan} plan`);
}

async function handleSubscriptionCreated(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;
  const plan = subscription.metadata?.plan;

  if (!userId || !plan) {
    console.error('Missing metadata in subscription:', subscription.id);
    return;
  }

  const supabase = createServiceRoleClient();
  
  // Store subscription details
  const { error } = await supabase
    .from('profiles')
    .update({
      plan: plan as 'pro' | 'premium',
      research_credits: plan === 'premium' ? 999999 : 50,
      stripe_subscription_id: subscription.id,
      stripe_customer_id: subscription.customer as string,
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to update subscription data:', error);
    throw error;
  }
}

async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;
  
  if (!userId) {
    console.error('Missing userId in subscription metadata:', subscription.id);
    return;
  }

  const supabase = createServiceRoleClient();
  
  // Update subscription status
  const { error } = await supabase
    .from('profiles')
    .update({
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to update subscription:', error);
    throw error;
  }
}

async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  const userId = subscription.metadata?.userId;
  
  if (!userId) {
    console.error('Missing userId in subscription metadata:', subscription.id);
    return;
  }

  const supabase = createServiceRoleClient();
  
  // Downgrade user to free plan
  const { error } = await supabase
    .from('profiles')
    .update({
      plan: 'free',
      research_credits: 3,
      stripe_subscription_id: null,
      stripe_customer_id: null,
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to downgrade user after subscription cancellation:', error);
    throw error;
  }

  console.log(`Downgraded user ${userId} to free plan after subscription cancellation`);
}

async function handleInvoicePaymentSucceeded(invoice: Stripe.Invoice) {
  const subscriptionId = invoice.subscription as string;
  
  if (!subscriptionId) {
    return;
  }

  // Retrieve subscription to get metadata
  const subscription = await stripe.subscriptions.retrieve(subscriptionId);
  const userId = subscription.metadata?.userId;
  const plan = subscription.metadata?.plan;

  if (!userId || !plan) {
    return;
  }

  // Refresh credits for monthly billing
  const supabase = createServiceRoleClient();
  
  const { error } = await supabase
    .from('profiles')
    .update({
      research_credits: plan === 'premium' ? 999999 : 50,
      updated_at: new Date().toISOString(),
    })
    .eq('user_id', userId);

  if (error) {
    console.error('Failed to refresh credits after payment:', error);
  }

  console.log(`Refreshed credits for user ${userId} on ${plan} plan`);
}

async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  // Handle failed payment - could send email notification, etc.
  console.log(`Payment failed for invoice: ${invoice.id}`);
}